import tkinter as tk
import numpy as np
import random
from scipy.optimize import minimize, least_squares
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import matplotlib.pyplot as plt

MAP_SIZE = 500
ball = [300, 200]     # posizione iniziale pallina
auto_mode = True      # pallina si muove da sola
NUM_RECEIVERS = 5     # numero ricevitori Bluetooth simulati
algo_mode = 2         # algoritmo attuale (1=griglia, 2=minimize, 3=least_squares)
errors = []           # storico errori per grafico
MAX_POINTS = 100      # quanti punti mostrare nel grafico

# --- Modelli ---
def distanza(p1, p2):
    return np.linalg.norm(np.array(p1) - np.array(p2))

def rssi_from_distance(d, A=-50, n=2, noise_std=2):
    if d <= 0:
        d = 0.1
    rssi = A - 10 * n * np.log10(d)
    rssi += random.gauss(0, noise_std)  # rumore
    return rssi

def distance_from_rssi(rssi, A=-50, n=2):
    return 10 ** ((A - rssi) / (10 * n))

# --- Algoritmi di trilaterazione ---
def trilaterazione_v1(receivers, d_stimati):
    def error(point):
        return sum((distanza(point, r) - d) ** 2 for r, d in zip(receivers, d_stimati))
    grid = [(x, y) for x in np.linspace(0, MAP_SIZE, 40) for y in np.linspace(0, MAP_SIZE, 40)]
    return min(grid, key=error)

def trilaterazione_v2(receivers, d_stimati):
    def error(point):
        return sum((distanza(point, r) - d) ** 2 for r, d in zip(receivers, d_stimati))
    res = minimize(lambda p: error(p), x0=np.array([MAP_SIZE/2, MAP_SIZE/2]), method="Nelder-Mead")
    return res.x if res.success else (MAP_SIZE/2, MAP_SIZE/2)

def trilaterazione_v3(receivers, d_stimati):
    def fun(p):
        return [distanza(p, r) - d for r, d in zip(receivers, d_stimati)]
    res = least_squares(fun, x0=np.array([MAP_SIZE/2, MAP_SIZE/2]))
    return res.x if res.success else (MAP_SIZE/2, MAP_SIZE/2)

def trilaterazione(receivers, d_stimati):
    if algo_mode == 1:
        return trilaterazione_v1(receivers, d_stimati)
    elif algo_mode == 2:
        return trilaterazione_v2(receivers, d_stimati)
    else:
        return trilaterazione_v3(receivers, d_stimati)

# --- GUI ---
root = tk.Tk()
root.title("Simulazione triangolazione Bluetooth")

canvas = tk.Canvas(root, width=MAP_SIZE, height=MAP_SIZE, bg="white")
canvas.pack(side=tk.LEFT)

frame = tk.Frame(root)
frame.pack(side=tk.TOP, fill="x", pady=5)

# Bottone toggle auto
def toggle_auto():
    global auto_mode
    auto_mode = not auto_mode
    btn_toggle.config(text="Auto: ON" if auto_mode else "Auto: OFF")

btn_toggle = tk.Button(frame, text="Auto: ON", command=toggle_auto)
btn_toggle.grid(row=0, column=0, padx=5)

# Bottoni algoritmi
def set_algo(mode):
    global algo_mode
    algo_mode = mode
    lbl_algo.config(text=f"Algoritmo: {mode}")

btn_v1 = tk.Button(frame, text="Algoritmo 1 (griglia)", command=lambda: set_algo(1))
btn_v2 = tk.Button(frame, text="Algoritmo 2 (minimize)", command=lambda: set_algo(2))
btn_v3 = tk.Button(frame, text="Algoritmo 3 (least_squares)", command=lambda: set_algo(3))
btn_v1.grid(row=0, column=1, padx=5)
btn_v2.grid(row=0, column=2, padx=5)
btn_v3.grid(row=0, column=3, padx=5)

lbl_algo = tk.Label(root, text="Algoritmo: 2")
lbl_algo.pack()

lbl_acc = tk.Label(root, text="Accuratezza: -- %", font=("Arial", 12))
lbl_acc.pack()

# Ricevitori iniziali (distribuiti a cerchio)
receiver_objs = []
center = MAP_SIZE / 2
radius = MAP_SIZE * 0.4
for i in range(NUM_RECEIVERS):
    angle = 2 * np.pi * i / NUM_RECEIVERS
    x = center + radius * np.cos(angle)
    y = center + radius * np.sin(angle)
    obj = canvas.create_oval(x-6, y-6, x+6, y+6, fill="black")
    receiver_objs.append(obj)

# Pallina reale e stimata
real_ball = canvas.create_oval(ball[0]-8, ball[1]-8, ball[0]+8, ball[1]+8, outline="red", width=2)
est_ball = canvas.create_oval(0, 0, 0, 0, outline="blue", width=2)

# --- Grafico live ---
fig, ax = plt.subplots(figsize=(4,2))
ax.set_title("Percentuale di accuratezza (px)")
ax.set_ylim(0, 100)
ax.set_xlim(0, MAX_POINTS)
line, = ax.plot([], [], "r-")
canvas_plot = FigureCanvasTkAgg(fig, master=root)
canvas_plot.get_tk_widget().pack(side=tk.RIGHT, fill="both", expand=True)

# --- Drag & Drop ---
dragging = {"obj": None, "dx": 0, "dy": 0, "is_ball": False}

def on_press(event):
    # Ricevitori
    for obj in receiver_objs:
        x0, y0, x1, y1 = canvas.coords(obj)
        if x0 <= event.x <= x1 and y0 <= event.y <= y1:
            dragging["obj"] = obj
            dragging["dx"] = event.x - (x0 + x1) / 2
            dragging["dy"] = event.y - (y0 + y1) / 2
            dragging["is_ball"] = False
            return
    # Pallina
    x0, y0, x1, y1 = canvas.coords(real_ball)
    if x0 <= event.x <= x1 and y0 <= event.y <= y1:
        dragging["obj"] = real_ball
        dragging["dx"] = event.x - (x0 + x1) / 2
        dragging["dy"] = event.y - (y0 + y1) / 2
        dragging["is_ball"] = True

def on_release(event):
    dragging["obj"] = None
    dragging["is_ball"] = False

def on_motion(event):
    if dragging["obj"]:
        x, y = event.x - dragging["dx"], event.y - dragging["dy"]
        if dragging["is_ball"]:
            canvas.coords(dragging["obj"], x-8, y-8, x+8, y+8)
        else:
            canvas.coords(dragging["obj"], x-6, y-6, x+6, y+6)

canvas.bind("<ButtonPress-1>", on_press)
canvas.bind("<ButtonRelease-1>", on_release)
canvas.bind("<B1-Motion>", on_motion)

# --- Loop aggiornamento ---
def update():
    global ball, errors

    if auto_mode and not dragging["is_ball"]:
        # Movimento casuale della pallina
        ball[0] += random.randint(-10, 10)
        ball[1] += random.randint(-10, 10)
        ball[0] = max(20, min(MAP_SIZE-20, ball[0]))
        ball[1] = max(20, min(MAP_SIZE-20, ball[1]))
        canvas.coords(real_ball, ball[0]-8, ball[1]-8, ball[0]+8, ball[1]+8)
    else:
        # Se la muovi tu, aggiorna le coordinate globali
        x0, y0, x1, y1 = canvas.coords(real_ball)
        ball[:] = [(x0+x1)/2, (y0+y1)/2]

    # Coordinate ricevitori
    receivers = []
    for obj in receiver_objs:
        x0, y0, x1, y1 = canvas.coords(obj)
        receivers.append(((x0+x1)/2, (y0+y1)/2))

    # Stima posizione
    rssi_values = [rssi_from_distance(distanza(r, ball)) for r in receivers]
    d_stimati = [distance_from_rssi(r) for r in rssi_values]
    stima = trilaterazione(receivers, d_stimati)

    # Aggiorna GUI
    canvas.coords(est_ball, stima[0]-8, stima[1]-8, stima[0]+8, stima[1]+8)

    # Accuratezza + errore
    err = distanza(ball, stima)
    acc = max(0, 100 * (1 - err / MAP_SIZE))
    lbl_acc.config(text=f"Accuratezza: {acc:.1f} %")

    # Aggiorna grafico
    errors.append(err)
    if len(errors) > MAX_POINTS:
        errors = errors[-MAX_POINTS:]
    line.set_data(range(len(errors)), errors)
    ax.set_ylim(0, max(50, max(errors)*1.2))
    canvas_plot.draw()

    root.after(200, update)

update()
root.mainloop()
